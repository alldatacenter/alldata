/*
 * Copyright (2022) Bytedance Ltd. and/or its affiliates
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <Analyzers/QualifiedName.h>
#include <DataTypes/IDataType.h>
#include <Interpreters/DatabaseAndTableWithAlias.h>
#include <Interpreters/IdentifierSemantic.h>
#include <Parsers/ASTIdentifier.h>
#include <Parsers/formatAST.h>
#include <Storages/IStorage.h>

#include <vector>
#include <list>
#include <memory>

namespace DB
{

struct FieldDescription;
using FieldDescriptions = std::vector<FieldDescription>;
struct Scope;
using ScopePtr = const Scope *;

namespace ErrorCodes
{
    extern const int AMBIGUOUS_IDENTIFIER;
}

struct FieldDescription
{
    String name;
    DataTypePtr type;

    /// ANSI SQL specific.
    QualifiedName prefix;

    /// track where this field comes from
    StoragePtr origin_table;
    IAST * origin_table_ast;
    String origin_column;
    size_t index_of_origin_scope;

    /// ANSI SQL specific.
    /// Materialized columns, alias columns and virtual columns are not substituted by asterisks,
    /// but derived columns should always be substituted. Only valid for column fields.
    /// s.a. https://clickhouse.com/docs/zh/sql-reference/statements/create/table/#materialized
    bool substituted_by_asterisk;

    FieldDescription(String name_,
                     DataTypePtr type_,
                     QualifiedName prefix_ = {})
        : FieldDescription(std::move(name_), std::move(type_), std::move(prefix_), nullptr, nullptr, "", -1, true)
    {}

    FieldDescription(String name_,
                     DataTypePtr type_,
                     QualifiedName prefix_,
                     StoragePtr origin_table_,
                     IAST * origin_table_ast_,
                     String origin_column_,
                     size_t index_of_origin_scope_,
                     bool substituted_by_asterisk_) :
        name(std::move(name_)),
        type(std::move(type_)),
        prefix(std::move(prefix_)),
        origin_table(std::move(origin_table_)),
        origin_table_ast(origin_table_ast_),
        origin_column(std::move(origin_column_)),
        index_of_origin_scope(index_of_origin_scope_),
        substituted_by_asterisk(substituted_by_asterisk_)
    {
    }

    FieldDescription withNewName(const String & new_name) const;
    FieldDescription withNewPrefix(const QualifiedName & new_prefix) const;
    void copyOriginInfo(const FieldDescription & source_field);

    // ANSI sql
    bool matchName(const QualifiedName & target_name) const;

    // Clickhouse SQL
    bool matchName(const String & target_name) const;
};

struct ResolvedField
{
    ScopePtr scope;
    size_t local_index;
    size_t hierarchy_index;

    ResolvedField(ScopePtr scope_, size_t local_index_);

    ResolvedField() = default;

    const FieldDescription & getFieldDescription() const;
};

/// Scope defines which names can be seen in current clause, thus can be used to analyze expressions.
///
/// Parent scope:
///   Scope is a hierarchical structure. If a name can not be resolved in current scope, it will delegate
///   to its parent to resolve, until to the root scope which has no parent.
///
/// Scope Type:
///   A RELATION scope is generated by a table scan/join...
///   A LAMBDA scope is generated when we enter a lambda function.
///
/// Scopes of a ASTSelectQuery:
///     Source scope: is generated by the FROM clause, used to analyze WHERE/GROUP BY/HAVING/SELECT.
///     Order-by scope: is generated by the SELECT clause, used to analyze ORDER BY/LIMIT BY.
///
/// Outer query scope:
///   Within a subquery expression(IN Subquery, scalar subquery, EXISTS subquery), all scopes have the outer
///   query's scope as their parent(directly or indirectly). Thus we can analyze co-related subqueries.
struct Scope
{
    enum class ScopeType
    {
        RELATION,
        LAMBDA
    };

    Scope() = delete;
    Scope(ScopeType type_, ScopePtr parent_, bool query_boundary_, FieldDescriptions field_description_)
        : type(type_), parent(parent_), query_boundary(query_boundary_), field_descriptions(std::move(field_description_))
    {
        if (!query_boundary_ && !parent)
            throw Exception("A non-query-boundary scope must have a parent scope.", ErrorCodes::LOGICAL_ERROR);
    }
private:
    ScopeType type;
    ScopePtr parent;
    bool query_boundary;
    FieldDescriptions field_descriptions;
public:
    ScopeType getType() const
    {
        return type;
    }

    const FieldDescriptions& getFields() const
    {
        return field_descriptions;
    }

    /// For ansi SQL, a qualified name will be resolved by below rules:
    ///   1) identifer's last name equal to field's name;
    ///   2) identifer's name prefix is a suffix of field's name prefix.
    ///      (Field: tpcds.store_sales.ss_store_sk, Identifier: store_sales.ss_store_sk)
    /// Ambiguous resolution is not allowed
    std::optional<ResolvedField> resolveFieldByAnsi(const QualifiedName & target_name) const
    {
        return resolveField<QualifiedName, true>(target_name);
    }

    /// For clickhouse SQL, qualified names have been normalized to canonical names in rewriting phase
    /// (see also TranslateQualifiedNamesVisitor). If there are multiple fields with a same canonical
    /// name, only the first fields will be used.
    /// E.g. suppose we have tables: t1 (`s` String, `t2.s` String)
    ///                              t2 (`s` String)
    /// "SELECT t2.s FROM t1, t2" will output the data of column `t2.s` of table t1.
    std::optional<ResolvedField> resolveFieldByClickhouse(const String & target_name) const
    {
        return resolveField<String, false>(target_name);
    }

    const FieldDescription & at(size_t n) const
    {
        return field_descriptions.at(n);
    }

    size_t size() const
    {
        return field_descriptions.size();
    }

    ScopePtr getLocalParent() const;
    bool isLocalScope(ScopePtr other) const;
    size_t getHierarchyOffset() const;
    size_t getHierarchySize() const;
    Names getOriginColumns() const;

private:
    template <typename T, bool check_ambiguous>
    std::optional<ResolvedField> resolveField(const T & target) const
    {
        ScopePtr scope = this;

        while (scope)
        {
            std::vector<size_t> matches;

            for (size_t i = 0; i < scope->size(); ++i)
            {
                if (scope->at(i).matchName(target))
                {
                    if constexpr (check_ambiguous)
                        matches.push_back(i);
                    else
                        return ResolvedField(scope, i);
                }
            }

            if constexpr (check_ambiguous)
            {
                if (matches.size() > 1)
                    throw Exception("Identifier " + target.toString() + " is ambiguous.", ErrorCodes::AMBIGUOUS_IDENTIFIER);
                else if (matches.size() == 1)
                    return ResolvedField(scope, matches.front());
            }

            scope = scope->parent;
        }

        return std::nullopt;
    }
};

struct ScopeFactory
{
    std::list<Scope> scopes;

    ScopePtr createScope(Scope::ScopeType type, ScopePtr parent, bool query_boundary, FieldDescriptions field_descriptions);
    ScopePtr createLambdaScope(ScopePtr parent, FieldDescriptions field_descriptions);
};

}
